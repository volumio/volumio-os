#  volumio-adaptive.script - universal boot splash with rotation and overlay messages
#
#  Copyright (C) 2025 Volumio Srl
#  
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2, or (at your option)
#  any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
#  02111-1307, USA.
#
#  Written by: Andrew Seredyn
#  Modified by: Nerd (adaptive rotation support with overlay messages)
#
#  References:
#    Freedesktop.org:
#      https://www.freedesktop.org/wiki/Software/Plymouth/Scripts/
#
#
#    Splash screen from video frames:
#     https://github.com/ToddServo/Plymouth-Animated-Boot-Screen-Creator
#

# --------------------------------- HELPER FUNCTIONS ------------------------------

fun StringLength(string) {
  pos = 0;
  str = String(string);
  while(str.CharAt(pos)) pos++;
  return pos;
}

fun StringContains(haystack, needle) {
  haystack_len = StringLength(haystack);
  needle_len = StringLength(needle);
  
  if (needle_len > haystack_len) return 0;
  if (needle_len == 0) return 0;
  
  for (i = 0; i <= haystack_len - needle_len; i++) {
    match = 1;
    for (j = 0; j < needle_len; j++) {
      if (haystack.CharAt(i + j) != needle.CharAt(j)) {
        match = 0;
        break;
      }
    }
    if (match == 1) return 1;
  }
  return 0;
}

# Map message text to overlay filename
# Note: Some messages contain variables (e.g., Version number)
# Pattern matching uses common substrings to handle variations
fun GetOverlayFilename(message_text) {
  if (StringContains(message_text, "Player preparing startup"))
    return "overlay-player-preparing";
  if (StringContains(message_text, "Finishing storage preparations"))
    return "overlay-finishing-storage";
  # Match on common part - actual message is "Version X.XXX prepared, please wait..."
  if (StringContains(message_text, "prepared, please wait for startup to finish"))
    return "overlay-player-prepared";
  if (StringContains(message_text, "Player re-starting now"))
    return "overlay-player-restarting";
  if (StringContains(message_text, "Receiving player update from USB"))
    return "overlay-receiving-update";
  if (StringContains(message_text, "Player update from USB completed"))
    return "overlay-update-complete";
  if (StringContains(message_text, "Remove USB used for update"))
    return "overlay-remove-usb";
  if (StringContains(message_text, "Performing factory reset"))
    return "overlay-factory-reset";
  if (StringContains(message_text, "Performing player update"))
    return "overlay-performing-update";
  if (StringContains(message_text, "Success, player restarts"))
    return "overlay-success-restart";
  if (StringContains(message_text, "Expanding internal storage"))
    return "overlay-expanding-storage";
  if (StringContains(message_text, "Waiting for USB devices"))
    return "overlay-waiting-usb";
  if (StringContains(message_text, "Player internal"))
    return "overlay-internal-update";
  
  return "";  # No match
}

# --------------------------------- DEBUG TOGGLE ----------------------------------

# To enable debug overlays (background + text), use:
# enable_debug_overlay = (Window.GetWidth() > -1);  # always true at runtime

# To disable debug overlays safely, use:
enable_debug_overlay = (Window.GetWidth() < 0);  # always false

# ------------------------------------ SEQUENCE -----------------------------------

Window.SetBackgroundTopColor(0.0, 0.0, 0.0);
Window.SetBackgroundBottomColor(0.0, 0.0, 0.0);

progress = 1;

# Rotation value patched at runtime by init-premount script
# Default value (0 = landscape, no rotation)
# Runtime detection will replace this line with actual plymouth= value
plymouth_rotation = 0;

# Fallback to system detection if available
detected_rotation = Plymouth.GetRotation();
if (detected_rotation) plymouth_rotation = detected_rotation;

# Build image subdirectory path
image_subdir = "sequence" + plymouth_rotation + "/";

# Determine effective dimensions for micro sequence test
# When plymouth=90 or 270, the display is in portrait mode
# but Window.GetWidth/Height returns raw framebuffer dimensions
screen_width = Window.GetWidth();
screen_height = Window.GetHeight();

if (plymouth_rotation == 90 || plymouth_rotation == 270) {
  # Swap dimensions for portrait orientations
  temp = screen_width;
  screen_width = screen_height;
  screen_height = temp;
}

# Use micro sequence for small or square framebuffers
use_micro_sequence = (screen_width <= 640) && (screen_height <= 640);

# -------------------------------- CALIBRATION BACKGROUND -------------------------

if (enable_debug_overlay) {
  layout_background = Image(image_subdir + "layout-constraint.png");
  bg_sprite = Sprite();
  bg_sprite.SetImage(layout_background);
  bg_sprite.SetX(Window.GetWidth() / 2 - layout_background.GetWidth() / 2);
  bg_sprite.SetY(Window.GetHeight() / 2 - layout_background.GetHeight() / 2);
  bg_sprite.SetZ(0);
}

# -------------------------------- DEBUG TEXT OVERLAY -----------------------------

if (enable_debug_overlay) {
  dbg_txt = Image.Text("ADAPTIVE SCRIPT OK", 1, 1, 1, 1, "Sans 8");
  dbg_sprite = Sprite();
  dbg_sprite.SetImage(dbg_txt);
  dbg_sprite.SetX(140);
  dbg_sprite.SetY(10);
  dbg_sprite.SetZ(9999);

  fb_txt = Image.Text("FB: " + String(Window.GetWidth()) + "x" + String(Window.GetHeight()), 1, 1, 0, 1, "Sans 8");
  fb_sprite = Sprite();
  fb_sprite.SetImage(fb_txt);
  fb_sprite.SetX(140);
  fb_sprite.SetY(30);
  fb_sprite.SetZ(9999);

  rot_txt = Image.Text("ROTATION: " + String(plymouth_rotation), 1, 1, 1, 1, "Sans 8");
  rot_sprite = Sprite();
  rot_sprite.SetImage(rot_txt);
  rot_sprite.SetX(140);
  rot_sprite.SetY(50);
  rot_sprite.SetZ(9999);

  mode_txt = Image.Text("MICRO: " + String(use_micro_sequence), 1, 1, 1, 1, "Sans 8");
  mode_sprite = Sprite();
  mode_sprite.SetImage(mode_txt);
  mode_sprite.SetX(140);
  mode_sprite.SetY(70);
  mode_sprite.SetZ(9999);
}

# ---------------------------------- ANIMATION SETUP ------------------------------

logo_sprite = Sprite();
logo_sprite.SetZ(1);  # Logo below overlay

if (use_micro_sequence) {
  for (i = 1; i <= 6; i++)
    micro_image[i] = Image(image_subdir + "micro-" + i + ".png");

  logo_sprite.SetImage(micro_image[1]);
  logo_sprite.SetX(Window.GetWidth() / 2 - micro_image[1].GetWidth() / 2);
  logo_sprite.SetY(Window.GetHeight() / 2 - micro_image[1].GetHeight() / 2);

} else {
  for (i = 1; i <= 90; i++)
    progress_image[i] = Image(image_subdir + "progress-" + i + ".png");

  logo_sprite.SetImage(progress_image[1]);
  logo_sprite.SetX(Window.GetWidth() / 2 - progress_image[1].GetWidth() / 2);
  logo_sprite.SetY(Window.GetHeight() / 2 - progress_image[1].GetHeight() / 2);
}

# ---------------------------------- MESSAGE OVERLAY SETUP ------------------------

# Determine overlay size based on smaller dimension breakpoint
smaller_dimension = Window.GetWidth();
if (Window.GetHeight() < smaller_dimension) {
  smaller_dimension = Window.GetHeight();
}

if (smaller_dimension < 400) {
  overlay_size_suffix = "-compact";
} else {
  overlay_size_suffix = "";
}

# Create overlay sprite (positioned on top of logo, Z=2, with transparent background)
message_overlay_sprite = Sprite();
message_overlay_sprite.SetZ(2);
message_overlay_sprite.SetOpacity(0);  # Hidden by default

# Store globals for message callback
global.image_subdir = image_subdir;
global.overlay_size_suffix = overlay_size_suffix;

# ---------------------------------- MESSAGE HANDLER ------------------------------

fun message_callback(text) {
  # Get overlay filename for this message
  overlay_filename = GetOverlayFilename(text);
  
  if (overlay_filename != "") {
    # Load appropriate overlay image
    overlay_path = global.image_subdir + overlay_filename + global.overlay_size_suffix + ".png";
    overlay_image = Image(overlay_path);
    
    if (overlay_image) {
      # Center overlay in framebuffer
      message_overlay_sprite.SetImage(overlay_image);
      message_overlay_sprite.SetX(Window.GetWidth() / 2 - overlay_image.GetWidth() / 2);
      message_overlay_sprite.SetY(Window.GetHeight() / 2 - overlay_image.GetHeight() / 2);
      message_overlay_sprite.SetOpacity(1);
    }
  } else {
    # No matching overlay, hide overlay sprite
    message_overlay_sprite.SetOpacity(0);
  }
}

# ------------------------------------- STATUS ------------------------------------

# Plymouth.SetUpdateStatusFunction(scroll_message_callback);

# ------------------------------------- RENDER ------------------------------------

Plymouth.SetMessageFunction(message_callback);

# ---------------------------------- REFRESH ANIMATION ----------------------------

fun refresh_callback() {
  if (use_micro_sequence) {
    frame = Math.Int(progress / 20) % 6 + 1;
    if (micro_image[frame])
      logo_sprite.SetImage(micro_image[frame]);
  } else {
    frame = Math.Int(progress / 3) % 90 + 1;
    if (progress_image[frame])
      logo_sprite.SetImage(progress_image[frame]);
  }
  progress++;
}

Plymouth.SetRefreshFunction(refresh_callback);
# ------------------------------------ END OF SCRIPT ------------------------------ 
# ---------------------------------------- V1.02 ----------------------------------